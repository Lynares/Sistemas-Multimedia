/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package evaluacionFinal;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.GradientPaint;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Stroke;
import java.awt.geom.*;
import java.util.ArrayList;

/**
 * Lienzo en el que se puede dibujar distintas FigurasGeometricas con distintos parámetros y se pueden editar.
 * @author Alvaro Maximino Linares Herrera
 */
public class Lienzo extends javax.swing.JPanel {
    
    ArrayList <FiguraGeometrica> vShape = new ArrayList();
    private static Color color = Color.BLACK;
    private static Color colorRelleno = Color.BLACK;
    private static Stroke stroke = new BasicStroke(1.0f);
    private static boolean relleno = false;
    private static boolean degradadoH = false;
    private static boolean degradadoV = false;
    private static int forma = 0;
    private Point2D p1 = new Point2D.Float();
    private Point2D p2 = new Point2D.Float();
    private Point2D p3 = new Point2D.Float();
    
    private FiguraGeometrica s = null;
    private static boolean editar = false;
    private static boolean discontinuo = false;
    private static float strokef;
    float[] gui={10};
    
    final static int PUNTO = 0;
    final static int LINEA = 1;
    final static int RECTANGULO = 2;
    final static int ELIPSE = 3;
    final static int CURVA = 4;
   
    /**
     * Constructor
     */
    public Lienzo() {
        initComponents();
    }
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setBackground(new java.awt.Color(255, 255, 255));
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                formMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                formMouseReleased(evt);
            }
        });
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                formMouseDragged(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void formMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMousePressed
        if(editar){
            s=getSelectedShape(evt.getPoint());
        }else{
        p1 = evt.getPoint();
        this.createShape(p1);
        vShape.add(s);
        }
    }//GEN-LAST:event_formMousePressed

    private void formMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseDragged
        
        if(editar && s!=null){  /* if(forma==CURVA)
                this.setLocation(s, p3);*/
            this.setLocation(s, evt.getPoint());    
            this.repaint();
        }else{
            p2= evt.getPoint();
            this.updateShape(p2);
            this.repaint();
        }
       
    }//GEN-LAST:event_formMouseDragged

    private void formMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseReleased
        
        if(editar && s!=null){
            /*if(forma==CURVA)
                this.setLocation(s, p3);*/
            this.setLocation(s, evt.getPoint());
            this.repaint();
        }else{
            p2= evt.getPoint();
            this.updateShape(p2);
            this.repaint();
        }
       
    }//GEN-LAST:event_formMouseReleased
    /**
     * Llama al método paint de la clase superior y pinta la FiguraGeometrica.
     *@param g es un objeto Graphics, el cuál será pasado a la clase superior y al método paintShapes
     *
     */
    @Override
    public void paint(Graphics g){  
        super.paint(g);
        this.paintShapes(g);
    }
    /**
     * Función que pintará una FiguraGeometrica con diferetes parámetros
     *@param g es un objeto Graphics, con el cual pintaremos las figuras con sus diferentes propiedades.
     *
     */
    public void paintShapes(Graphics g){
        //Función en la que se se hace lo que en la práctica anterior haciamos en paint(). salvo el super.paint
        //esta función será llamada en paint() y hará todo el trabajo relativo a los shapes.
        Graphics2D g2d = (Graphics2D)g;
        
        for(FiguraGeometrica s:vShape) {
            //if(relleno) s.setRelleno(true);
            if(!discontinuo){
            g2d.setStroke(s.getStroke());
            }else{
            g2d.setStroke(s.getStroke());
            }
           
            if(s.getRelleno()){
                g2d.setPaint(s.getColorRelleno());
                g2d.fill(s);
            }
            int x1 = 0, x2 = 0, y1 = 0, y2 = 0, xc = 0, yc = 0;
            
            GradientPaint gradiente = null;
                
            //horizontal
            if(s.getDegradadoV()&& forma!=PUNTO && forma!=LINEA && forma!=CURVA){
                if(forma==RECTANGULO){
                    //Variables para el caso de un rectangulo
                    xc=(int) ((Rectangulo)s).getCenterX();
                    y1=(int) ((Rectangulo)s).getMaxY();     
                    y2=(int) ((Rectangulo)s).getMinY();
                }else if(forma==ELIPSE){
                    //Variables para el caso de una elipse
                    xc=(int) ((Elipse)s).getCenterX();
                    y1=(int) ((Elipse)s).getMaxY();     
                    y2=(int) ((Elipse)s).getMinY();
                }
                gradiente = new GradientPaint(xc, y2, s.getColor(), xc, y1, s.getColorRelleno());
                g2d.setPaint(gradiente);
                g2d.fill(s);
            }
            //vertical 
            if(s.getDegradadoH() && forma!=PUNTO && forma!=LINEA && forma!=CURVA){ 
                if(forma==RECTANGULO){
                    //Variables para el caso de un rectangulo
                    x1=(int) ((Rectangulo)s).getMaxX();
                    x2=(int) ((Rectangulo)s).getMinX();
                    yc=(int) ((Rectangulo)s).getCenterY();
                }else if(forma==ELIPSE){
                    //Variables para el caso de una elipse
                    x1=(int) ((Elipse)s).getMaxX();
                    x2=(int) ((Elipse)s).getMinX();
                    yc=(int) ((Elipse)s).getCenterY();
                }
                gradiente = new GradientPaint(x2, yc, s.getColor(), x1, yc, s.getColorRelleno());
                g2d.setPaint(gradiente);
                g2d.fill(s);
            }
        
            g2d.setPaint(s.getColor());
            g2d.draw(s);
            
        }
    }
    /**
     *A su vez inicializaremos la figura geométrica con los valores de color, color de relleno, tipo de trazo y relleno.
     *@param p1 es un objeto Point2D, con el que crearemos nuestra figura, asignandoselo como primer punto. 
     *
     */
    private void createShape(Point2D p1){
        //Crearemos un Shape de diferente tipo según la forma seleccionada
        if(p1==null) return;
        
        switch(forma){
            case PUNTO:
                s = new Linea(p1,p1);
                s.setColor(color);
                s.setColorRelleno(colorRelleno);
                s.setStroke(stroke);
                s.setRelleno(relleno);
                s.setDegradadoH(degradadoH);
                s.setDegradadoV(degradadoV);
                break;
            case LINEA:
                s = new Linea(p1,p1);
                s.setColor(color);
                s.setColorRelleno(colorRelleno);
                s.setStroke(stroke);
                s.setRelleno(relleno);
                s.setDegradadoH(degradadoH);
                s.setDegradadoV(degradadoV);
                break;
            case RECTANGULO:
                s = new Rectangulo(p1.getX(), p1.getY(), 1, 1);
                s.setColor(color);
                s.setColorRelleno(colorRelleno);
                s.setStroke(stroke);
                s.setRelleno(relleno);
                s.setDegradadoH(degradadoH);
                s.setDegradadoV(degradadoV);
                break;
            case ELIPSE:
                s = new Elipse(p1.getX(), p1.getY(), 1, 1);
                s.setColor(color);
                s.setColorRelleno(colorRelleno);
                s.setStroke(stroke);
                s.setRelleno(relleno);
                s.setDegradadoH(degradadoH);
                s.setDegradadoV(degradadoV);
                break;
            case CURVA:
                p3.setLocation((int)(p1.getX()+p2.getX()), (int)(p1.getY()+p2.getY()));
                s = new Curva(p1, p2, p3);
                s.setColor(color);
                s.setColorRelleno(colorRelleno);
                s.setStroke(stroke);
                s.setRelleno(relleno);
                s.setDegradadoH(degradadoH);
                s.setDegradadoV(degradadoV);
                break;
        }
    }
    /**
     *Método con el que indicaremos el segundo punto de la figura. 
     *@param p2 es un objeto Point2D.
     *
     */
    private void updateShape(Point2D p2){
        //El punto no lo consideraremos
        if(forma==PUNTO || p2==null || p1==null) return;
        switch(forma){
            
            case LINEA:
                if(s instanceof Linea)((Linea)s).setLine(p1,p2);
                break;
            case RECTANGULO:
                if(s instanceof Rectangulo)
                    ((Rectangulo)s).setFrameFromDiagonal(p1, p2);
                break;
            case CURVA:
                if(s instanceof Curva){
                    p3.setLocation((int)(p1.getX())+50, (int)(p1.getY())-50);
                    ((Curva)s).setCurve(p1, p2, p3);     
                }
                break;
            default:
                if(s instanceof Elipse)
                    ((Elipse)s).setFrameFromDiagonal(p1, p2);
                break;
        }
    }
    /**
     * Método para modificar la posición de una figura.
     *@param sha es un objeto FiguraGeometrica, que será la que cambiaremos de posición
     *@param pos es un objeto Point2D, con el que iremos actualizando la figura para ponerla en otro lugar.
     *
     */
    private void setLocation(FiguraGeometrica sha, Point2D pos){
        /*
         *Consideramos los distintos casos para recalcular la posición
         */
        if(s instanceof Punto){
            double dx=pos.getX()-((Punto)sha).getX1();
            double dy=pos.getY()-((Punto)sha).getY1();
            Point2D newp2 = new Point2D.Double(((Punto)sha).getX2()+dx,((Punto)sha).getY2()+dy);
            ((Punto)sha).setLine(pos,newp2);
        }
        if(s instanceof Linea){
            double dx=pos.getX()-((Linea)sha).getX1();
            double dy=pos.getY()-((Linea)sha).getY1();
            Point2D newp2 = new Point2D.Double(((Linea)sha).getX2()+dx,
            ((Linea)sha).getY2()+dy);
            ((Linea)sha).setLine(pos,newp2);
        }
        if(s instanceof Rectangulo){
            double dx=pos.getX()-((Rectangulo)sha).getMinX();
            double dy=pos.getY()-((Rectangulo)sha).getMinY();
            Point2D newp2 = new Point2D.Double(((Rectangulo)sha).getMaxX()+dx,
            ((Rectangulo)sha).getMaxY()+dy);
            ((Rectangulo)sha).setFrameFromDiagonal(pos,newp2);
        }    
        if(s instanceof Elipse){
            double dx=pos.getX()-((Elipse)sha).getMinX();
            double dy=pos.getY()-((Elipse)sha).getMinY();
            Point2D newp2 = new Point2D.Double(((Elipse)sha).getMaxX()+dx,
            ((Elipse)sha).getMaxY()+dy);
            ((Elipse)sha).setFrameFromDiagonal(pos,newp2);
        }
        if(s instanceof Curva){
            double dx=pos.getX()-((Curva)sha).getX1();
            double dy=pos.getY()-((Curva)sha).getY1();
            p3.setLocation((int)(p1.getX())+50, (int)(p1.getY())-50);
            Point2D newp2 = new Point2D.Double(((Curva)sha).getX2()+dx,
            ((Curva)sha).getY2()+dy);
            ((Curva)sha).setCurve(pos.getX(), pos.getY(), p3.getX(),p3.getY(),newp2.getX(),newp2.getY());
        }
    }
    /**
     *@param li es un objeto de tipo Linea, que será la linea a la que miraremos si el punto está cerca.
     *@param p es un objeto de tipo Point2D, el cual es el punto que queremos comprobar si está cerca de la linea.
     *@return true si el punto está a una distancia cercana de la Linea, false en caso contrario.
     */
    private boolean isNear(Linea li, Point2D p){
        //ptSegDist nos devuelve la distancia desde un punto al segmento de la linea
        //lo usamos para poder mover los puntos, ya que con ptLineDist no funcionaba
        return li.ptSegDist(p)<=2.0;
    }
    /**
     * Método usado para comprobar si un punto esta dentro de la figura.
     *@param p es un objeto Point2D, el punto que queremos comprobar si esta cerca de la figura.
     *@return FiguraGeometrica, en caso de que el punto este cerca de la figura o null en caso de que no lo este.
     */
    private FiguraGeometrica getSelectedShape(Point2D p){
        /* 
         *Modificamos el metodo que encontramos en la práctica 6 añadiendole un contains.
         *Contains solo devuelve true si el Shape tiene algún área, como las lineas y los 
         *puntos no tienen área nos devuelve false siempre, por lo cual para las lineas 
         *usaremos el método isNear.
         */
        for(FiguraGeometrica s:vShape)
            if(s instanceof Linea){
            if(isNear((Linea)s,p)) return s;
            }else{
            if(s.contains(p)) return s;
            }
        return null;
    }
    
    /**
    *@return true si editar está activo en este Lienzo, false si está desactivado en este Lienzo.
    */
    public boolean getEditar(){
        return editar;
    }
    /**
    *Modifica el parámetro editar de Lienzo.
     * @param ed boolean, indica si se puede editar o no.
    */
    public void setEditar(boolean ed){
        editar=ed;
        if(s!=null)
            s.setRelleno(ed);
    }
    /**
    *@return true si discontinuo está activo en este Lienzo, false si está desactivado en este Lienzo.
    */
    public boolean getDiscontinuo(){
        return discontinuo;
    }
    /**
    *Modifica el parámetro discontinuo de Lienzo.
     * @param dis boolean, indica si se pinta discontinuo o no.
    */
    public void setDiscontinuo(boolean dis){
            discontinuo=dis;
            if(s!=null)
                s.setDiscontinuo(dis);
    }
    /**
     *Le indicamos el color con el que queremos pintar.
     *@param c es un objeto Color, que usamos para pintar el color principal
     */
    public void setColor(Color c){
        color=c;
        if(s!=null)
            s.setColor(c);
    }
    /**
     *@return Nos devuelve le parámetro color de Lienzo.
     */
    public Color getColor(){
        return color;
    }
    /**
     * Le indicamos el color con el que queremos pintar el relleno.
     *@param c es un objeto Color, que usamos para pintar el relleno
     */
    public void setColorRelleno(Color c){
        colorRelleno=c;
        if(s!=null)
            s.setColorRelleno(c);
    }
    /**
     *@return Nos devuelve le parámetro color de relleno de Lienzo.
     */
    public Color getColorRelleno(){
        return colorRelleno;
    }
    /**
     *Dependiendo de si el parámetro discontinuo es true o false, inicializaremos un Stroke u otro.
     *@param stro es un objeto float, lo usamos para definir el grosor del trazo.
     */
    public void setStroke(float stro){
        //Nos servirá para cambiar el Stroke
        if(!discontinuo){
        stroke=new BasicStroke(stro);
        }
        else if(discontinuo){
        stroke=new BasicStroke( stro, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND, 10, gui, 0 ) ;
        }
        this.repaint();
    }
    /**
     *Nos devuelve el grosor seleccionado en float.
     * @return float con el valor del grosor del trazo.
     */
    public float getStroke(){
        return strokef;
    }
    /**
     * Seleccionamos con int entre 0 y 4 el tipo de FiguraGeometrica que podemos dibujar.
     *@param f es un int, que usaremos para cambiar entre las 5 formas de dibujo que tenemos.
     */
    public void setForma(int f){
        forma=f;
    }
    /**
     *@return Nos devuelve un int con la forma que tenemos seleccionada.
     */
    public int getForma(){
        return forma;        
    }
    /**
     * Cambia el relleno de Lienzo y de FiguraGeometrica.
     *@param re es un boolean, que usaremos para cambiar el relleno, tanto de lienzo como de la figura seleccionada.
     */
    public void setRelleno(boolean re){
            relleno=re;
            if(s!=null)
                s.setRelleno(re);
    }
    /**
     *@return Nos devuelve un boolean con el valor de relleno.
     */
    public boolean getRelleno(){
            return relleno;
    }
    /**
     * Cambia el degradado de Lienzo y de la FiguraGeometrica a horizontal.
     *@param re es un boolean, que usaremos para cambiar el degradado, tanto de lienzo como de la figura seleccionada.
     */
    public void setDegradadoH(boolean re){
            degradadoH=re;
            if(s!=null)
                s.setDegradadoH(re);
    }
    /**
     *@return Nos devuelve un boolean con el valor del degradado horizontal.
     */
    public boolean getDegradadoH(){
            return degradadoH;
    }
    /**
     * Cambia el degradado de Lienzo y de la FiguraGeometrica a vertical.
     *@param re es un boolean, que usaremos para cambiar el degradado, tanto de lienzo como de la figura seleccionada.
     */
    public void setDegradadoV(boolean re){
            degradadoV=re;
            if(s!=null)
                s.setDegradadoV(re);
    }
    /**
     *@return Nos devuelve un boolean con el valor del degradado vertical.
     */
    public boolean getDegradadoV(){
            return degradadoV;
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
